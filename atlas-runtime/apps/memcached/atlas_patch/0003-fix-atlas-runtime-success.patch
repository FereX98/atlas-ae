From e50a5739e03c4ae109e96690ce5c82c1abbc0012 Mon Sep 17 00:00:00 2001
From: Lei Chen <ls.cat@outlook.com>
Date: Thu, 1 Dec 2022 15:34:44 +0800
Subject: [PATCH 3/4] fix: atlas runtime success

---
 atlas.h      | 29 +++++++++++++++++++++++------
 proto_text.c |  7 ++++++-
 2 files changed, 29 insertions(+), 7 deletions(-)

diff --git a/atlas.h b/atlas.h
index d07b85e..0d46843 100644
--- a/atlas.h
+++ b/atlas.h
@@ -3,6 +3,7 @@
 #include <pointer_shim.h>
 #include <bks_types.h>
 #include <string.h>
+#include <stdlib.h>
 #include "memcached.h"
 
 extern void *global_psf;
@@ -14,6 +15,11 @@ static void inline atlas_init()
     memset(global_psf, 0x0, BKS_PSF_MMAP_SIZE);
 }
 
+static void inline atlas_enable_runtime_fetch()
+{
+    memset(global_psf, 0xf, BKS_PSF_MMAP_SIZE);
+}
+
 /* [Atlas] as the orig object ptr is 0x7fxxxxx, the most siginificant bit of our unique ptr metadata must be 1 */
 static inline bool is_atlas_ptr(void *ptr)
 {
@@ -31,14 +37,25 @@ static inline bool is_atlas_ptr(void *ptr)
         }                                                                     \
     } while (0)
 
+static inline item * alloc_item(item* ptr){
+    item* ret = malloc(ITEM_ntotal(ptr));
+    memcpy(ret, ptr, ITEM_ntotal(ptr));
+    return ret;
+}
 
 static inline item* atlas_get_item(item** item_ptr, atlas_unique_ptr **up, bool force_paging){
     item* ret = *item_ptr;
     if(is_atlas_ptr(ret)){
         *up = (atlas_unique_ptr*)item_ptr;
 
-        ret = force_paging ? atlas_up_deref_get_paging(*up) 
-                           : atlas_up_deref_get(*up);
+        // ret = force_paging ? atlas_up_deref_get_paging(*up) 
+        //                    : atlas_up_deref_get(*up);
+        // fprintf(stderr, "Im no scope\n");
+
+        ret = atlas_up_deref_no_scope(*up);
+        // ret = (item*)((*up)->handle >> 17);
+        // ret = atlas_up_deref_raw(*up, 0);
+        // ret = alloc_item((item*)((*up)->handle >> 17));
     }else{
         *up = NULL;
     }
@@ -47,8 +64,8 @@ static inline item* atlas_get_item(item** item_ptr, atlas_unique_ptr **up, bool
 
 /* [Atlas] this should be called when holding hv lock, if the item is in the hashtable */
 static inline void atlas_put_item(atlas_unique_ptr *up, void *ptr){
-    const uint64_t kAddrShift = 17; /* a hack to extract the addr from metadata */
-    if(up && (up->handle >> kAddrShift) == (uint64_t)ptr){
-        atlas_up_deref_put(up, ptr);
-    }
+    // const uint64_t kAddrShift = 17; /* a hack to extract the addr from metadata */
+    // if(up && (up->handle >> kAddrShift) == (uint64_t)ptr){
+    //     atlas_up_deref_put(up, ptr);
+    // }
 }
\ No newline at end of file
diff --git a/proto_text.c b/proto_text.c
index 01c75b6..db8d7f0 100644
--- a/proto_text.c
+++ b/proto_text.c
@@ -18,6 +18,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include "atlas.h"
+bool atlas_enable = false;
 
 #define META_SPACE(p) { \
     *p = ' '; \
@@ -2801,7 +2802,11 @@ void process_command_ascii(conn *c, char *command) {
         // Various get commands are very common.
         WANT_TOKENS_MIN(ntokens, 3);
         if (strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) {
-
+            if(!atlas_enable){
+                atlas_enable = true;
+                atlas_enable_runtime_fetch();
+                fprintf(stderr, "First `get` command, enable the runtime fetch\n");
+            } 
             process_get_command(c, tokens, ntokens, false, false);
         } else if (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0) {
 
-- 
2.25.1

