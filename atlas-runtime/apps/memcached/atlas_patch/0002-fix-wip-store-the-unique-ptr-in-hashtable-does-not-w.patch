From c5b7918149fc86337ccc244a3d1c43aec9b5e3c5 Mon Sep 17 00:00:00 2001
From: Lei Chen <ls.cat@outlook.com>
Date: Wed, 30 Nov 2022 20:00:49 +0800
Subject: [PATCH 2/4] fix-wip: store the unique ptr in hashtable does not work

---
 assoc.c      |  9 ++++++---
 atlas.h      |  4 +++-
 items.c      | 11 +++--------
 memcached.c  | 24 ++++++++++++++----------
 memcached.h  |  2 ++
 proto_text.c | 29 ++++++++++++++++++++---------
 thread.c     | 10 ++++++++++
 7 files changed, 58 insertions(+), 31 deletions(-)

diff --git a/assoc.c b/assoc.c
index e9334fc..a42c7db 100644
--- a/assoc.c
+++ b/assoc.c
@@ -86,7 +86,9 @@ item *atlas_assoc_find_paging(const char *key, const size_t nkey, const uint32_t
         item *old_it = it;
         it = atlas_get_item(&it->h_next, up, true /* force_paging */);
         ++depth;
+        // fprintf(stderr, "put 1 before \n");
         atlas_put_item(up_old, old_it);
+        // fprintf(stderr, "put 1 end \n");
     }
     MEMCACHED_ASSOC_FIND(key, nkey, depth);
     return ret;
@@ -132,7 +134,9 @@ static item** _hashitem_before (const char *key, const size_t nkey, const uint32
         if(it && ((nkey != it->nkey) || memcmp(key, ITEM_key(it), nkey))){
             pos = &it->h_next;
             /* [Atlas] simply drop the refcnt, as the raw ptr is protected by memcached's hv lock */
+        // fprintf(stderr, "put 2 before \n");
             atlas_put_item(it_up, it);
+        // fprintf(stderr, "put 2 end \n");
             continue;
         }
         break;
@@ -211,7 +215,7 @@ void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {
     item *it = NULL;
     atlas_unique_ptr *it_up = NULL;
     item **before = _hashitem_before(key, nkey, hv, &it, &it_up);
-    fprintf(stderr, "old item %p, unique_ptr handle 0x%lx", (void*)it, it_up->handle);
+    // fprintf(stderr, "old item %p, unique_ptr handle 0x%lx", (void*)it, it_up->handle);
 
     if (it) {
         item *nxt;
@@ -222,13 +226,12 @@ void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {
         nxt = it->h_next;
         it->h_next = 0;   /* probably pointless, but whatever. */
         *before = nxt;
-        atlas_put_item(it_up, it);
         return;
     }
     /* Note:  we never actually get here.  the callers don't delete things
        they can't find. */
     assert(*before != 0);
-    fprintf(stderr, "atlas delete ok\n");
+    // fprintf(stderr, "atlas delete ok\n");
 }
 
 
diff --git a/atlas.h b/atlas.h
index 363f652..d07b85e 100644
--- a/atlas.h
+++ b/atlas.h
@@ -45,8 +45,10 @@ static inline item* atlas_get_item(item** item_ptr, atlas_unique_ptr **up, bool
     return ret;
 }
 
+/* [Atlas] this should be called when holding hv lock, if the item is in the hashtable */
 static inline void atlas_put_item(atlas_unique_ptr *up, void *ptr){
-    if(up){
+    const uint64_t kAddrShift = 17; /* a hack to extract the addr from metadata */
+    if(up && (up->handle >> kAddrShift) == (uint64_t)ptr){
         atlas_up_deref_put(up, ptr);
     }
 }
\ No newline at end of file
diff --git a/items.c b/items.c
index d76d591..d9ce908 100644
--- a/items.c
+++ b/items.c
@@ -284,7 +284,7 @@ item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
     /* This is a large item. Allocate a header object now, lazily allocate
      *  chunks while reading the upload.
      */
-    fprintf(stderr, "alloc: chunk size max %d, flags %d, ntotal %ld\n", settings.slab_chunk_size_max, flags, ntotal);
+    // fprintf(stderr, "alloc: chunk size max %d, flags %d, ntotal %ld\n", settings.slab_chunk_size_max, flags, ntotal);
     if (ntotal > settings.slab_chunk_size_max) {
         /* We still link this item into the LRU for the larger slab class, but
          * we're pulling a header from an entirely different slab class. The
@@ -318,7 +318,7 @@ item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
     }
 
     assert(it->it_flags == 0 || it->it_flags == ITEM_CHUNKED);
-    fprintf(stderr, "it flags %d\n", it->it_flags);
+    // fprintf(stderr, "it flags %d\n", it->it_flags);
     //assert(it != heads[id]);
 
     /* Refcount is seeded to 1 by slabs_alloc() */
@@ -329,15 +329,12 @@ item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
      */
     if (settings.temp_lru &&
             exptime - current_time <= settings.temporary_ttl) {
-        fprintf(stderr, "temp lru\n");
         id |= TEMP_LRU;
     } else if (settings.lru_segmented) {
         id |= HOT_LRU;
-        fprintf(stderr, "hot lru\n");
     } else {
         /* There is only COLD in compat-mode */
         id |= COLD_LRU;
-        fprintf(stderr, "cold lru\n");
     }
     it->slabs_clsid = id;
 
@@ -538,7 +535,6 @@ void do_item_unlink(item *it, const uint32_t hv) {
         stats_state.curr_items -= 1;
         STATS_UNLOCK();
         item_stats_sizes_remove(it);
-        fprintf(stderr, "unlinked item %p\n", (void*)it);
         assoc_delete(ITEM_key(it), it->nkey, hv);
         // item_unlink_q(it);
         do_item_remove(it);
@@ -573,8 +569,7 @@ void do_item_remove(item *it) {
 
 /* Bump the last accessed time, or relink if we're in compat mode */
 void do_item_update(item *it) {
-    // MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
-    fprintf(stderr, "update lru segmented %d\n",settings.lru_segmented);
+    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
 }
 
 int do_item_replace(item *it, item *new_it, const uint32_t hv, atlas_unique_ptr** new_it_up) {
diff --git a/memcached.c b/memcached.c
index 2f04db9..dc4b5b8 100644
--- a/memcached.c
+++ b/memcached.c
@@ -1021,8 +1021,9 @@ void conn_set_state(conn *c, enum conn_states state) {
  */
 void resp_reset(mc_resp *resp) {
     if (resp->item) {
-        item_remove(resp->item);
+        atlas_item_remove(resp->item, resp->item_up);
         resp->item = NULL;
+        resp->item_up = NULL;
     }
     if (resp->write_and_free) {
         free(resp->write_and_free);
@@ -1208,8 +1209,9 @@ mc_resp* resp_finish(conn *c, mc_resp *resp) {
     mc_resp *next = resp->next;
     if (resp->item) {
         // TODO: cache hash value in resp obj?
-        item_remove(resp->item);
+        atlas_item_remove(resp->item, resp->item_up);
         resp->item = NULL;
+        resp->item_up = NULL;
     }
     if (resp->write_and_free) {
         free(resp->write_and_free);
@@ -1679,22 +1681,24 @@ enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t h
 
         if (do_store) {
             STORAGE_delete(c->thread->storage, old_it);
-            fprintf(stderr, "before do store: old_it %p, old_up %p, it %p\n", (void*)old_it, (void*)old_up, (void*)it);
+            // fprintf(stderr, "before do store: old_it %p, old_up %p, it %p\n", (void*)old_it, (void*)old_up, (void*)it);
             if(old_it != NULL){
-                fprintf(stderr, "before do store: old it not null: old up val 0x%lx\n", old_up->handle);
+                // fprintf(stderr, "before do store: old it not null: old up val 0x%lx\n", old_up->handle);
             }
             item_replace(old_it, it, hv, it_up);
-            fprintf(stderr, "end do store \n");
+            // fprintf(stderr, "end do store \n");
             stored = STORED;
         }
 
-        fprintf(stderr, "old it %p, old_up 0x%lx\n", (void*)old_it, old_up->handle);
+        // fprintf(stderr, "old it %p, old_up 0x%lx\n", (void*)old_it, old_up->handle);
         do_item_remove(old_it);         /* release our reference */
         /* [Atlas] after item_replace, the old_up has been destroyed, and in fact, it points to the unique ptr of `it` now */
         if(!do_store){
+        // fprintf(stderr, "put 3 before \n");
             atlas_put_item(old_up, old_it);
+        // fprintf(stderr, "put 3 end \n");
         }
-        fprintf(stderr, "after remove old it %p, old_up 0x%lx\n", (void*)old_it, old_up->handle);
+        // fprintf(stderr, "after remove old it %p, old_up 0x%lx\n", (void*)old_it, old_up->handle);
         if (new_it != NULL) {
             // append/prepend end up with an extra reference for new_it.
             do_item_remove(new_it);
@@ -1738,7 +1742,7 @@ enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t h
             stored, comm, ITEM_key(it), it->nkey, it->nbytes, it->exptime,
             ITEM_clsid(it), c->sfd);
     // atlas_assoc_insert_get(
-    fprintf(stderr, "finish comlete nread\n");
+    // fprintf(stderr, "finish comlete nread\n");
     return stored;
 }
 
@@ -3190,10 +3194,10 @@ static void drive_machine(conn *c) {
             break;
 
         case conn_nread:
-            fprintf(stderr, "conn nread before\n");
+            // fprintf(stderr, "conn nread before\n");
             if (c->rlbytes == 0) {
                 complete_nread(c);
-                fprintf(stderr, "conn nread end\n");
+                // fprintf(stderr, "conn nread end\n");
                 break;
             }
 
diff --git a/memcached.h b/memcached.h
index 7cca88c..0bd9acb 100644
--- a/memcached.h
+++ b/memcached.h
@@ -750,6 +750,7 @@ typedef struct _mc_resp {
     io_pending_t *io_pending; /* pending IO descriptor for this response */
 
     item *item; /* item associated with this response object, with reference held */
+    struct atlas_unique_ptr *item_up;
     struct iovec iov[MC_RESP_IOVCOUNT]; /* built-in iovecs to simplify network code */
     int chunked_total; /* total amount of chunked item data to send. */
     uint8_t iovcnt;
@@ -978,6 +979,7 @@ item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do
 item *item_touch(const char *key, const size_t nkey, uint32_t exptime, conn *c);
 int   item_link(item *it);
 void  item_remove(item *it);
+void  atlas_item_remove(item *item, struct atlas_unique_ptr* up);
 int   item_replace(item *it, item *new_it, const uint32_t hv, struct atlas_unique_ptr **new_it_up);
 void  item_unlink(item *it);
 
diff --git a/proto_text.c b/proto_text.c
index 87f042a..01c75b6 100644
--- a/proto_text.c
+++ b/proto_text.c
@@ -174,13 +174,13 @@ void complete_nread_ascii(conn *c) {
         }
         out_string(c, "CLIENT_ERROR bad data chunk");
     } else {
-      fprintf(stderr, "store item before \n");
+    //   fprintf(stderr, "store item before \n");
       /* [Atlas] the unique_ptr will be NULL if the store does not succeed */
       ret = store_item(it, comm, c, &it_up);
       if(it_up){
-        fprintf(stderr, "store item success: up 0x%lx, it %p, up inner ptr 0x%lx\n", it_up->handle, (void*)it, it_up->handle >> 47);
+        // fprintf(stderr, "store item success: up 0x%lx, it %p, up inner ptr 0x%lx\n", it_up->handle, (void*)it, it_up->handle >> 47);
       }else{
-        fprintf(stderr, "store item fail, it_up is NULL\n");
+        // fprintf(stderr, "store item fail, it_up is NULL\n");
       }
 
 #ifdef ENABLE_DTRACE
@@ -238,8 +238,12 @@ void complete_nread_ascii(conn *c) {
 
     c->set_stale = false; /* force flag to be off just in case */
     c->mset_res = false;
-    item_remove(c->item);       /* release the c->item reference */
-    atlas_put_item(it_up, c->item);
+    // fprintf(stderr, "put 4 before , %p\n", (void*)it_up);
+    // if(it_up){
+    //   fprintf(stderr, "put 4 midd , handle 0x%lx\n", it_up->handle);
+    // }
+    atlas_item_remove(c->item, it_up);       /* release the c->item reference */
+    // fprintf(stderr, "put 4 end %p\n", (void*)it_up);
     c->item = 0;
 }
 
@@ -654,9 +658,12 @@ static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,
                     resp->item = NULL;
                 }
 #else
-                resp->item = NULL;
+                resp->item = it;
+                resp->item_up = up;
 #endif
-                atlas_put_item(up, it);
+    // fprintf(stderr, "put 5 before \n");
+    //             atlas_put_item(up, it);
+    // fprintf(stderr, "put 5 end \n");
             } else {
                 pthread_mutex_lock(&c->thread->stats.mutex);
                 if (should_touch) {
@@ -2758,6 +2765,10 @@ void process_command_ascii(conn *c, char *command) {
         return;
     }
 
+    // if(strcmp(tokens[COMMAND_TOKEN].value, "add") != 0 && strcmp(tokens[COMMAND_TOKEN].value, "get") 
+    //    && strcmp(tokens[COMMAND_TOKEN].value, "set") != 0){
+    //     fprintf(stderr, "command is %s\n", tokens[COMMAND_TOKEN].value);
+    //    }
     // Meta commands are all 2-char in length.
     char first = tokens[COMMAND_TOKEN].value[0];
     if (first == 'm' && tokens[COMMAND_TOKEN].length == 2) {
@@ -2806,7 +2817,7 @@ void process_command_ascii(conn *c, char *command) {
         }
     } else if (first == 's') {
         if (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) {
-            fprintf(stderr, "set command\n");
+            // fprintf(stderr, "set command\n");
             WANT_TOKENS_OR(ntokens, 6, 7);
             process_update_command(c, tokens, ntokens, comm, false);
         } else if (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0) {
@@ -2824,7 +2835,7 @@ void process_command_ascii(conn *c, char *command) {
     } else if (first == 'a') {
         if ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
             (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) ) {
-            fprintf(stderr, "add command\n");
+            // fprintf(stderr, "add command\n");
             WANT_TOKENS_OR(ntokens, 6, 7);
             process_update_command(c, tokens, ntokens, comm, false);
         } else {
diff --git a/thread.c b/thread.c
index c837dad..ab915db 100644
--- a/thread.c
+++ b/thread.c
@@ -867,6 +867,16 @@ void item_remove(item *item) {
     item_unlock(hv);
 }
 
+void atlas_item_remove(item *item, atlas_unique_ptr* up) {
+    uint32_t hv;
+    hv = hash(ITEM_key(item), item->nkey);
+
+    item_lock(hv);
+    do_item_remove(item);
+    atlas_put_item(up, item);
+    item_unlock(hv);
+}
+
 /*
  * Replaces one item with another in the hashtable.
  * Unprotected by a mutex lock since the core server does not require
-- 
2.25.1

